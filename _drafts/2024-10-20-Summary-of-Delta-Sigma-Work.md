---
category: drafts
layout: default
title: Summary of Delta Sigma Work
---

# Summary of Delta Sigma Work (December 2023 - )

My interest in delta-sigma ADCs was first awakened while investigating Agilent's Multislope IV. In November 2023, I finally came to understand how delta-sigma modulation worked, and was ready to take on the fine details of how it was implemented in Multislope IV. 

I was on a trip to Poland to visit a couple of friends when the idea to work on a delta-sigma modulator of the precision variety firmly entrenched itself in my head.

Mark was curious about how simply and cheaply a multibit modulator could be made, and the idea was to use a comparator to somehow implement (what I know know is called) time domain quantization. Instead of using purely 'binary' feedback as with multislope - that is, a high or low on the comparator output would denote the 'state' of the integrator (positive or negative), so feedback of opposite polarity could be applied - the *time* the comparator was high or low was to be measured, to derive a rough estimate of how much charge had been present in the integrator during the cycle where it was measured, and inject enough (roughly quantized) charge in the next cycle to balance it.

I did take a look at how it could possibly be implemented (using PIO on the RP2040, of course), but didn't get very far with that for a reason I cannot remember.

In the days leading up to the new year (2024), I was also in touch with John Pickering who provided me crucial material with respect to his work on delta-sigma modulators, more specifically, the usage of a PWM DAC to achieve high linearity (in his own words: "reliably achieves linearity of 40ppb"). With PWM feedback, linearity is purely dependent on how accurately an edge can be placed within the PWM period. The ultimate limiting factor is random jitter or phase noise. In most cases (as explained in the HP Journal April 1989), this comes from the controller (FPGA/MCU), and has been successfully mitigated (Jaromir, Takovsky) with the addition of a garden-variety crystal oscillator and a D-latch (e.g. `74, `273). XOs are available at very reasonable prices with a jitter of less than 0.7psrms. At that point, the ultimate limiting factor to linearity is the jitter of the analog switch. Slow clocking and higher order modulators were the secret to the Pickering ADC's performance.

I also discovered a paper written by a Logan Penrod, as part of his Master's thesis. A very interesting idea was presented - a single-loop (in other words, single op-amp) higher order integrator. Such a construction would normally be unstable and prone to oscillations, but if the Rs and Cs in the circuit are sized correctly, one can achieve a 'normal' first order (-20dB/decade) rolloff in the 'forward' direction, i.e. with the signal transfer function. The noise transfer function is, however, of a higher order.

A higher-order modulator, consisting of multiple op-amps, was, in my line of thinking, impractical. Penrod's idea was therefore an ideal solution for implementing a higher order integrator with a single, precise composite amplifier loop.

Penrod implemented his ideas in LTspice, providing a rough 'recipe' with which I was able to replicate his experiments. I used his schematic and simulation commands as the basis of my further simulations. LTspice confirmed his higher-order single-loop integrator. High open-loop gain equated to a very low noise 'floor', that is, the loop could null out any frequencies in that band, while providing a steep 80dB/decade rolloff into higher frequencies.

I was also fascinated by Andrew Holme's MASH modulator page, which has a detailed explanation and implementation of how a multistage noise shaping algorithm worked. A single MASH stage is basically a first-order delta sigma modulator, and cascading multiple allows one to generate random noise with a higher order characteristic.

As the clock in the town hall struck 00:00 on the 01.01.2024, I came to the realization that a hybrid modulator could be constructed. A single analog integrator's output could be digitized, passed through a few MASH stages, and fed back in the form of PWM to close the loop. This would theoretically achieve a fourth-order noise transfer function, meaning very low quantization noise in the frequency band of interest - my goal was < -160dB at 10Hz.

I would not get an opportunity to simulate the hybrid modulator till 10 months later, after I had gotten familiar with QSPICE. LTspice, while being a very poweful tool (using behavioural voltage sources to perform calculations was my favourite trick), does not let you easily implement a digital algorithm like MASH.

QSPICE's custom C++ DLL modules let you include code in the simulation, so it was perfect for MASH. The simulation results were disappointing - despite adding four MASH orders to the analog modulator, the resulting NTF was still mostly first order. There was a clean 20dB/decade slope, but after a certain frequency, the higher-order response from the MASH modulators shows up as a steeper slope.

This was not *entirely* unexpected, since I did read about that on the EEVBlog forums:

> An additional third method shall be proposed, which is a certain combination of the 2 methods above:
3. The input signal is continuously integrated by only one analog integrator. The integrator output is digitised by a fast high-resolution ADC. The ADC output is integrated at least by 2 additional digital integrators, and the latter digital signals are combined to a digital modulator output (third or higher order). Closing the control loop via current switches, the errors of the ADC are highpass filtered, but only with 1st order filtering. The differential linearity of the ADC is essential for obtaining low "noise" at medium frequency. The output result is extracted from the switch control by suitable digital lowpass filtering (4th order or higher).

Since most of my previous work involved perfecting the modulator, the digital filter was set aside, to be worked on after getting the former properly working. However, I have occasionally taken to reading the odd paper about optimum filtering. There seem to be two classes of optimum filters - linear and non-linear. Linear filters can be analyzed in the time and frequency domain, whereas non-linear filters are usually recursive and 'deconstruct' the working of the modulator to find a mathematically optimum bitstream decoder. Hein et. al. in 1993 seems to have discovered the first mathematically optimum algorithm to decode the output of a first order delta sigma modulator (basically, a multislope modulator), called the 'zoomer' algorithm. However, this method, while being (relatively) easy to understand, is not immune to imperfect quantization. Kavusi et. al. came up with a (once again, relatively) intuitive analysis method for the algorithm in 2005. Wang, in 2020, presented the most understandable explanation of the zoomer algorithm so far, and supplemented it with a calculated example. Improvements in terms of thermal noise suppression and tolerance to imperfect quantization were also presented in the form of a modified zoomer algorithm. Tentatively, a 10x reduction in the number of modulation cycles to achieve the same resolution is possible. A completely linear computationally efficient decoder was also published by Wang in 2023. It involves a custom, real-time computable filter kernel, with which the modulator bitstream is convolved.

The advantages of using an optimum filter is that the lower number of cycles needed to achieve a given resolution can be used to increase the time period of a single modulation cycle, thereby increasing linearity (which is propotional jitter/period).

Of great consequence is a paper from Georgakopoulous in 2004, of which Pickering was a co-author. In the section 'System description and evaluation', the secrets from Pickering 2001 and Pickering 2005 are laid bare. In Pickering 2005, Pickering makes a rather cryptic statement: 'Logic interpolates 5 bit PWM to 10 bit ADC.... In effect a 5th order modulator.' Georgakopoulous 2004, however, goes on to elaborate that the loop quantizer is 10 bits, and since the PWM is only 4 bits, over a number of modulation (PWM) cycles, the 10 bit value is represented with 4 bit PWM, similar to how a delta-sigma DAC might work. This proves the statement from Pickering 2005 to be technically incorrect. Presumably, the 4X50 filter from Pickering 2001 is just multiple moving average stages.

Since Georgakopoulous 2004 does not elaborate upon the interpolation method, I assumed a higher-order MASH modulator would be a good fit. For example, a 4th-order MASH modulator would produce a correct average in rougly M/8 (compared to M for a 1-st order Modulator) modulation cycles. Pickering 2004 \[2\] goes into greater depth than Georgakopoulous 2004 (or, the other way around, the latter is a summary of the former). The interpolation algorithm is described to be '\[an\] interpolation scheme, similar to first order integration'. That confirms an interpolator that is similar or identical to a first-order MASH modulator.

The 'centralized' PWM in Pickering 2005 serves to keep the integrator automatically centered.

## The magic of centered PWM

On the 11.12.2024, I found myself going through the April 1989 edition of the HP journal yet again. That document could be considered a primary source of information regarding multislope integrating ADCs, going into depth about the actual circuit implementation and practical considerations. There is also a section that describes the runup algorithm and PWM patterns. I spent a day thinking about patterns 1 and 2 as described in figure 7. My theory was that they were used in combination with feedback 'history', as in, the previous comparator state was stored, and along with the current comparator state, formed a two-bit code that mapped to one of the four patterns described, in an effort to keep the integrator centered. Since the amount of charge transferred during patterns 1 and 2 is essentially zero, this theory is unlikely.

That got me thinking about patterns 3 and 4, which were just regular 'centered' PWM, but with overlapping complementary duty cycles. Centered PWM, in the context of microcontrollers, is more formally known as 'phase-accurate' PWM, whereas 'regular' PWM is 'fast' PWM. This is the terminology I shall adopt going ahead.

There are two ways to implement phase-accurate PWM: 'arithmetic' complement and 'boolean' inversion. The former involves calculating the duty cycle of the complementary phase by subtracting the duty cycle from the maximum possible value, and this is written to the compare register. The result is an overlapping PWM with two different duty cycles whereby the 'center' has both phases turned on and results in zero effect. The latter inverts the first phase in a 'boolean' fashion, i.e., when the first phase is high, the second phase is low.

While sketching both implementations and the resulting integrator patterns, it occured to me that boolean inversion resulted in an integrator waveform that was *very* similar to Pickering's centered PWM, as described in Pickering 2005. The addition of dead time between the two phases would make an almost exact match, only lacking the central zero period shared by both phases, which would be difficult to easily implement anyway.

After running a few simulations, I realized that phase-accurate PWM solved a lot of problems (or, rather, implementation difficulties) that fast PWM had. While investigating Multislope IV, I came to the conclusion that to center the integrator, the feedforward function needed to have a quadratic characteristic. However, with phase-accurate PWM, only a simple linear function was needed, which can easily be implemented in passives - which is exactly what Multislope IV does, and also takes advantage of the ADC's differential inputs to invert the feedforward signal after scaling.

There are also three points on the resulting waveform that are more or less constant with respect to amplitude and time, and are therefore perfect for digitization - the beginning, middle and end of the PWM period. I also came to the conclusion that the 'gain' of the centering loop could be calibrated by varying the exact time at which the integrator was digitized, i.e. vary the phase of the sampling signal till perfect centering is achieved.

If implementing a more complex function is feasible, the waveform can even be made to have a fixed amplitude, something that would not be possible with fast PWM.

After reading "Sigma Delta Conversion Used for Motor Control" (Jens Sorensen, 01.08.2015), I was once again inspired, and came up with a calibration scheme that involved setting the synchronization signal (to which the digitizing ADC is locked) to twice the PWM signal's frequency, and an arbitrary phase offset. If successive samples differed, then the phase is either increased or decreased till the difference is minimized. Essentially, the same point of the triangle waveform is being digitized. This is possible only with 0 input or symmetric swings.

The RP2040's PWM peripheral makes all of this possible. The PWM counters are transparent and can be set to any value between 0 and 65535, while the counter compare registers which set the duty cycle accept zero and full scale (inclusive) to deliver 0% and 100% duty cycles. The counter is clocked from a divider, further adding to flexibility. The main clock can also be set precisely, further aiding flexibility. All six PWM counters can be started synchronously and stay in lockstep during operation. Interrupts can be generated on counter wrap. Channels can also be phase-shifted forwards or backwards relative to other channels. The last two facts can be combined powerfully - if one channel is phase-shifted forwards with respect to the PWM DAC channel, its interrupt can be used to set the counter compare values of the DAC channel on time, resulting in no feedback loop delay.

## An interesting non-linear delta-sigma decoder

I came across a very interesting paper titled 'A novel decoder for Delta-Sigma modulator providing both high resolution and low latency' by Sherkat and Bibyk, 1999.

The method described is particularly interesting because the authors mention suitability for DC decoding, as well as incredible numbers for mean square error (negative infinite dB and -300dB) along with plots that show a flat line, where sinc1 and sinc3 filters have large peak-to-peak noise. The filter is also touted to have a 38-bit resolution.

The paper starts off with the regular discrete-time difference equation for a first-order modulator, but the formula they derive is basically identical to the multislope ADC equation in The Art of Electronics (3rd ed., pg. 919), consisting of two parts: the first averages the number of ones in the bitstream and scales it in accordance with the reference voltage, and the second part calculates the 'residue', that is, the difference between the integrator state and the start and end of the conversion (or observation period) and scales it by dividing it by the number of cycles over which the conversion/observation took place.

The above is a fairly convetional method of calculating the input voltage of the system, but the authors take this one step further. A value for the number of cycles is assumed, called L\*, where the 'residue' is zero, i.e. the integrator ends where it starts. In that case, averaging over L\* bits from the bitstream (note: from any starting point) results in *exactly* the input voltage. From the multislope point of view, this proposition is sensible - when the input voltage can be represented exactly by an integral number of positive and negative reference cycles, the residue is zero.

The calculation of L\* is rather involved - n bits from the bitstream are shifted into memory, and an autocorrelation is run with the incoming bitstream. The number of shifts at which the autocorrelation value is maximum must be the optimum L\* value.

I was able to get an LLM to write a Python script which generated a first-order bitstream and compared simple averaging to the correlation filter for an input range of -10V to +10V, and a step size of 0.1V. Surprisingly enough, the average filter performed better in terms of INL and computation time.

After thinking about it, I realized that this made sense. Going by the same multislope analogy, the bit patterns for such small input step sizes would span a greater length than the shifting memory I had set (I tried 10, 100, 1000, 10000 and 100000, the average filter winning in every case). The idea behind the filter, albeit clever, seemed impractical. The large discrepancies between my results and the one from the paper lead me to believe that my implementation might somehow be wrong.
